{"id":820631411,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1665549373,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/820631411/","is_pending":"Not Pending","title":"Shortest Path in Binary Matrix","memory":"N/A","code":"class Solution {\npublic:\nclass Disjointset {\n\t//parent\n    int* p;\n    //rank\n\tint* r;\n\npublic:\n\tDisjointset(int n)\n\t{\n\t\tp = new int[n];\n\t\tr = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tp[i] = -1;\n\t\t\tr[i] = 1;\n\t\t}\n\t}\n\n\t// Find function\n\tint find(int i)\n\t{\n\t\tif (p[i] == -1)\n\t\t\treturn i;\n\n\t\treturn p[i] = find(p[i]);\n\t}\n\n\t// Union function\n\tvoid unite(int x, int y)\n\t{\n\t\tint s1 = find(x);\n\t\tint s2 = find(y);\n\n\t\tif (s1 != s2) {\n\t\t\tif (r[s1] < r[s2]) {\n\t\t\t\tp[s1] = s2;\n\t\t\t\tr[s2] += r[s1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp[s2] = s1;\n\t\t\t\tr[s1] += r[s2];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass Graph {\n\tvector <pair<int, pair <int,int>> > edgelist;\n\tint V;\n\npublic:\n\tGraph(int V) { this->V = V; }\n\n\tvoid addEdge(int cost, pair<int, int> source_dest)\n\t{\n\t\tedgelist.push_back({cost, source_dest});\n\t}\n\n\tint min_sum()\n\t{\n\t\tsort(edgelist.begin(), edgelist.end());\n        Disjointset s(V);\n        int sum=0;\n        int cost=0;\n        for (auto edge : edgelist) {\n            cost=edge.first;\n            int a = edge.second.first;\n            int b = edge.second.second;\n\n            if(s.find(a)!=s.find(b))\n            {\n                s.unite(a,b);\n                sum=sum+cost;\n            }\n\n\n        }\n        return sum;\n\t}\n};\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int n=points.size();\n        if(n==1)  // edge case \n            return 0;\n        //no of edges = n-1*n/2\n        int no_edges=(n-1)*n/2;\n        Graph g(n);\n         // find distances from each pair of points\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                    int d=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]);\n                    g.addEdge(d,make_pair(i,j));\n            }\n        }\n        return g.min_sum();\n        \n\n    }\n};\n\n","compare_result":null,"title_slug":"shortest-path-in-binary-matrix","has_notes":false}