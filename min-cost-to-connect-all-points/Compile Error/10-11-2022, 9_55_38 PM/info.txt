{"id":820575504,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1665543338,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/820575504/","is_pending":"Not Pending","title":"Min Cost to Connect All Points","memory":"N/A","code":"class Solution {\npublic:\nclass DSU {\n\tint* parent;\n\tint* rank;\n\npublic:\n\tDSU(int n)\n\t{\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = -1;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\t// Find function\n\tint find(int i)\n\t{\n\t\tif (parent[i] == -1)\n\t\t\treturn i;\n\n\t\treturn parent[i] = find(parent[i]);\n\t}\n\n\t// Union function\n\tvoid unite(int x, int y)\n\t{\n\t\tint s1 = find(x);\n\t\tint s2 = find(y);\n\n\t\tif (s1 != s2) {\n\t\t\tif (rank[s1] < rank[s2]) {\n\t\t\t\tparent[s1] = s2;\n\t\t\t\trank[s2] += rank[s1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparent[s2] = s1;\n\t\t\t\trank[s1] += rank[s2];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass Graph {\n\tvector <pair<int, pair<pair<int, int>,pair <int,int>> >> edgelist;\n\tint V;\n\npublic:\n\tGraph(int V) { this->V = V; }\n\n\tvoid addEdge(int cost, pair<pair<int, int>,pair<int, int>> source_dest)\n\t{\n\t\tedgelist.push_back({cost, source_dest});\n\t}\n\n\tvoid kruskals_mst()\n\t{\n\t\tsort(edgelist.begin(), edgelist.end());\n\n\t\tDSU s(V);\n\t\tint ans = 0;\n\t\tcout << \"Following are the edges in the \"\n\t\t\t\t\"constructed MST\"\n\t\t\t<< endl;\n\t\tfor (auto edge : edgelist) {\n\t\t\tint w = edge[0];\n\t\t\tint x = edge[1];\n\t\t\tint y = edge[2];\n\n\t\t\tif (s.find(x) != s.find(y)) {\n\t\t\t\ts.unite(x, y);\n\t\t\t\tans += w;\n\t\t\t\tcout << x << \" -- \" << y << \" == \" << w\n\t\t\t\t\t<< endl;\n\t\t\t}\n\t\t}\n\t\n\t\tcout << \"Minimum Cost Spanning Tree: \" << ans;\n\t}\n};\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int n=points.size();\n        if(n==1)  // edge case \n            return 0;\n        //no of edges = n-1*n/2\n        int no_edges=(n-1)*n/2;\n        Graph g(no_edges);\n         // find distances from each pair of points\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                    int d=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]);\n                    g.addEdge(d,make_pair(make_pair(),make_pair(i,j)));\n            }\n        }\n\n\n    }\n};","compare_result":null,"title_slug":"min-cost-to-connect-all-points","has_notes":false}