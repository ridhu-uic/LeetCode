{"id":820590557,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1665545066,"status":10,"status_display":"Accepted","runtime":"521 ms","url":"/submissions/detail/820590557/","is_pending":"Not Pending","title":"Min Cost to Connect All Points","memory":"58.3 MB","code":"class Solution {\npublic:\nclass DSU {\n\tint* parent;\n\tint* rank;\n\npublic:\n\tDSU(int n)\n\t{\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = -1;\n\t\t\trank[i] = 1;\n\t\t}\n\t}\n\n\t// Find function\n\tint find(int i)\n\t{\n\t\tif (parent[i] == -1)\n\t\t\treturn i;\n\n\t\treturn parent[i] = find(parent[i]);\n\t}\n\n\t// Union function\n\tvoid unite(int x, int y)\n\t{\n\t\tint s1 = find(x);\n\t\tint s2 = find(y);\n\n\t\tif (s1 != s2) {\n\t\t\tif (rank[s1] < rank[s2]) {\n\t\t\t\tparent[s1] = s2;\n\t\t\t\trank[s2] += rank[s1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparent[s2] = s1;\n\t\t\t\trank[s1] += rank[s2];\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass Graph {\n\tvector <pair<int, pair <int,int>> > edgelist;\n\tint V;\n\npublic:\n\tGraph(int V) { this->V = V; }\n\n\tvoid addEdge(int cost, pair<int, int> source_dest)\n\t{\n\t\tedgelist.push_back({cost, source_dest});\n\t}\n\n\tint kruskals_mst()\n\t{\n\t\tsort(edgelist.begin(), edgelist.end());\n        DSU s(V);\n        int sum=0;\n        int cost=0;\n        for (auto edge : edgelist) {\n            cost=edge.first;\n            int a = edge.second.first;\n            int b = edge.second.second;\n\n            if(s.find(a)!=s.find(b))\n            {\n                s.unite(a,b);\n                sum=sum+cost;\n            }\n\n\n        }\n        return sum;\n\t}\n};\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int n=points.size();\n        if(n==1)  // edge case \n            return 0;\n        //no of edges = n-1*n/2\n        int no_edges=(n-1)*n/2;\n        Graph g(n);\n         // find distances from each pair of points\n        for(int i=0;i<n;i++)\n        {\n            for(int j=i+1;j<n;j++)\n            {\n                    int d=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]);\n                    g.addEdge(d,make_pair(i,j));\n            }\n        }\n        return g.kruskals_mst();\n        \n\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"min-cost-to-connect-all-points","has_notes":false}