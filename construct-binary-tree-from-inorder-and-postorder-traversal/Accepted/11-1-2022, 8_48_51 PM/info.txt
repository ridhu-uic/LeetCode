{"id":835054479,"lang":"cpp","lang_name":"C++","time":"3 months, 2 weeks","timestamp":1667353731,"status":10,"status_display":"Accepted","runtime":"40 ms","url":"/submissions/detail/835054479/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"26.5 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* maketree(vector<int>& inorder, int in_st, int in_en, vector<int>& postorder, int post_st, int post_en, map<int, int>&inorder_position){\n        if(in_st>in_en || post_st>post_en){return NULL;}\n        TreeNode* root= new TreeNode(postorder[post_en]);\n        int pos=inorder_position[postorder[post_en]];\n        int rght=pos-in_st;\n        root->left=maketree(inorder, in_st, pos-1, postorder, post_st, post_st+rght-1, inorder_position);\n        root->right=maketree(inorder, pos+1, in_en, postorder, post_st+rght, post_en-1, inorder_position);\n        return root;\n    }\n\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        map <int, int> inorder_position;\n        for(int i=0; i<inorder.size(); i++){inorder_position[inorder[i]]=i;}\n        TreeNode* root=maketree(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1, inorder_position);\n        return root;\n    }\n\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","has_notes":false}